"""
Function library for working with dataframes generated by O2_binding.py in the autoq library
"""

import sys
import pandas as pd
import numpy as np
import re

from scipy import stats
import sklearn.linear_model as lm
from sklearn import preprocessing
from sklearn import metrics

#Parameters from DFT and conversion factors
O2_tpssh = -150.3285416 #Total Free Energy of pcm O2 with 6-31+g* basis
O2_31gp = -150.32246450  #Total Free Energy of pcm O2 with 6-31g* basis
Ht2eV = 27.211 #electron volts per Hartree


def AssembleDf(input_df):
    """Calculate oxygen binding parameters parsed from separate jobs
    Parameters
    ----------
    input_df : pandas dataframe
        Pandas dataframe returned from O2_binding.py in the autoq library

    Returns
    -------
    df : pandas dataframe
        Input dataframe modified with additional Series calculated from the input dataframe
    """

    df = input_df.copy()
    #df = df.dropna()
    df = AddTypeName(df)

    df = df.assign(O2_binding_energy = (df['CatalystO2_Energy'] - df['Catalyst_Energy'] - O2_31gp)*Ht2eV) #O2 binding energy
    df = df.assign(O2_CHELPG = df['Oxygen_1_CHELPG']+df['Oxygen_2_CHELPG']) #Charge on O2 after binding
    df = df.assign(IE = (df['Catalyst_c1_Energy'] - df['Catalyst_Energy'])*Ht2eV) #Ionization energy
    df = df.assign(Ch_Diff = df['Catalyst_Active_Site_CHELPG'] - df['Catalyst_c1_Active_Site_CHELPG']) #Charge difference from cation

    df = df[df['O2_binding_energy'] > -2.0]
    df = df[df['O2_binding_energy'] < 0.5]

    return df

def AddEnergyDiffs(input_df, energy_columns, diff_names, shift=[0.,0.,0.]):
    """Take the difference between the energy of the bare catalyst and a list of other energies in the dataframe
    Parameters:
    -----------
    input_df: pandas dataframe
        must contain a column labeled 'Catalyst_Energy', and columns named for each of the energy columns
    energy_columns: list
        the names for each column to take as the difference from 'Catalyst_Energy'
    diff_names: list
        the name for the new columns that are added, which are the energy differences
    """

    #for i, column_name in enumerate(energy_columns):
    #    df = df.assign(diff_name[i] = (df[column_name] - df['Catalyst_Energy'])*Ht2eV)

    df = input_df.copy()
    print(df.shape)
    df = df.assign(O2H_diff = (df['CatalystOOH_Energy'] - df['Catalyst_Energy'] - shift[0])*Ht2eV)
    df = df.assign(O_diff = (df['CatalystO_Energy'] - df['Catalyst_Energy'] - shift[1])*Ht2eV)
    df = df.assign(OH_diff = (df['CatalystOH_Energy'] - df['Catalyst_Energy'] - shift[2])*Ht2eV)
    return df


def CleanDf(input_df, active_sites=None, O2_bl=None, active_site_id=None, O2_binding=None):
    """Removes entries that are outside particular parameters
    Parameters
    ----------
    input_df : pandas dataframe
        Pandas dataframe returned from O2_binding.py in the autoq library
    active_sites : list
        All accepted active sites of the catalyst (by atom index)
    O2_bl : list
        A length 2 list of the min and max accepted bond length b/w O2 and the catalyst
    active_site_id : string
        the atomic symbol of the active site atom

    Returns
    -------
    df : pandas dataframe
        Input dataframe pruned by the criteria set in the input
    """

    df = input_df.copy()

    if O2_binding != None:
        df = df[df['O2_binding_energy'] > O2_binding[0]]
        df = df[df['O2_binding_energy'] < O2_binding[1]]

    if active_sites != None:
        df_list = []
        for site in active_sites:
            df_list.append(df[df['Active_Site'] == site])
        df = pd.concat(df_list)

    if active_site_id != None:
        df = df[df['Active_Site_ID'] == active_site_id]

        if O2_bl == None:
            O2_bl = bond_length_dict[active_site_id]

        df = df[df['Cat-O2_Bond_Length'] > O2_bl[0]]
        df = df[df['Cat-O2_Bond_Length'] < O2_bl[1]]

    return df

def AddCatTag(input_df, split_str='-', tag_series_name='Catalyst_File_Name'):
    """Add a series to the catalyst df that specifies the base catalyst name
    Parameters:
    -----------
    input_df : pandas dataframe
        df from O2_binding.py
    split_str : string
        for if we want to split the entries of the tag series by something other than '-'
    tag_series_name : string
        name for the series that contains the tag information

    Returns
    -------
    df : pandas dataframe
        Input dataframe with additional tag series
    """

    df = input_df.copy() #so we don't modify dataframe in-place, as per functional programming

    cat_type_list = []
    tag_list = []
    for name in df[tag_series_name]:
        name_split = name.split(split_str) #split_str is an input for if we switch formatting
        cat_type_list.append(name_split[0]) #<catalyst_name>-func<number>

        #select number after func or functionalized
        tag = re.match(r"([a-z]+)([0-9]+)", name_split[1].split('_')[0])
        print(tag.group(1))
        print(tag.group(2))
        tag_list.append(int(tag.group(2)))
        #tag_list.append(int(name_split[1].split('_')[0][4:])) #selects number after func from filename


    df = df.assign(Tag = tag_list)
    df = df.assign(Catalyst_Type = cat_type_list)

    return df

def AddTypeName(df):
    """ Add the type of catalyst (tetry, tetrid, mepyr) as a new column to pandas dataframe"""
    cat_type_list = []
    tag_list = []
    for name in df['Catalyst_File_Name']:
        #name_split = name.split('-')
        #tag_list.append(int(name_split[1].split('_')[0][4:]))

        ds_ind = name.find('-')
        und_ind = name.find('_')
        if ds_ind < und_ind and ds_ind > 0:
            spl_char = '-'
        else:
            spl_char = '_'

        name_split = name.split(spl_char)
        cat_type_list.append(name_split[0])

        ## Find the number after func
        match = re.search('func(\d+)', name)
        if match:
            #print(match.group(1))
            tag_list.append(int(match.group(1)))
        #tag_list.append(int(name_split[1][4:]))

    print(cat_type_list)
    df = df.assign(Tag = tag_list)
    df = df.assign(Catalyst_Type = cat_type_list)
    return df

def AssignSubsts(df, func_file):
    cat_tag_list = []
    subst_list_1, subst_list_2 = [], []
    func_list_1, func_list_2 = [], []
    with open(func_file, 'r') as f:
        for line in f:
            spline = line.split()
            cat_tag = int(spline[0])
            func_info = ''.join(spline[2:]).split(")(")
            subst_sites = ''.join(c for c in func_info[0] if c not in "')(").split(',')
            for j, item in enumerate(subst_sites):
                try:
                    subst_sites[j] = int(item)
                except:
                    subst_sites[j] = None
            #subst_sites = [int(item) for item in subst_sites]
            funcs = ''.join(c for c in func_info[1] if c not in "')(").split(',')

            cat_tag_list.append(cat_tag)
            subst_list_1.append(subst_sites[0])
            if len(subst_sites) == 2:
                subst_list_2.append(subst_sites[1])
            else:
                subst_list_2.append('None')

            func_list_1.append(funcs[0])
            if len(funcs) == 2:
                func_list_2.append(funcs[1])
            else:
                func_list_2.append('None')

    temp_df = pd.DataFrame({'Func_1': func_list_1, 'Func_2': func_list_2, 'Tag': cat_tag_list, \
                            'Sub_1': subst_list_1, 'Sub_2': subst_list_2})
    df = df.merge(temp_df, on='Tag', how='left')
    return df


def SaveAssembledSubsts(df_csv, func_infile, outfile):
    df = pd.DataFrame.from_csv(df_csv)
    df = AssembleDf(df)
    df = AssignSubsts(df, func_infile)
    df.to_csv(outfile)
